HTTP 是每个 Web 开发人员都应该知道的协议，因为它为整个 Web 提供动力。了解 HTTP 当然可以帮助您开发更好的应用程序。

在这篇文章中，我将讨论什么是HTTP，它是如何形成的，它今天所处的位置，以及我们是如何走到这一步的

## 什么是 HTTP？

首先，什么是HTTP？HTTP 是一种基于 TCP/IP 的应用层通信协议，它标准化了客户端和服务器之间的通信方式。它定义了如何在互联网上请求和传输内容。通过应用层协议，我的意思是它只是一个抽象层，它标准化了主机（客户端和服务器）的通信方式。HTTP 本身依赖于 TCP/IP 来获取客户端和服务器之间的请求和响应。默认情况下，使用 TCP 端口 80，但也可以使用其他端口。但是，HTTPS 使用端口 443。

## HTTP/0.9 - The One Liner （1991年）

HTTP的第一个记录版本是[HTTP/0.9](https://www.w3.org/Protocols/HTTP/AsImplemented.html)，它于1991年提出。这是有史以来最简单的协议;有一个称为 GET 的方法。如果客户端必须访问服务器上的某个网页，它将发出如下所示的简单请求

```
GET /index.html
```

来自服务器的响应如下所示

```
(response body)
(connection closed)
```

也就是说，服务器将收到请求，以 HTML 作为响应进行回复，一旦内容被传输，连接将被关闭。曾经有

- 无标题
- `GET`是唯一允许的方法
- 响应必须是 HTML

正如你所看到的，该协议实际上只不过是即将到来的垫脚石。

## HTTP/1.0 - 1996年

1996 年，HTTP 的下一个版本，即 HTTP/1.0 的发展，比原始版本有了很大的改进。

与仅针对 HTML 响应设计的 HTTP/0.9 不同，HTTP/1.0 现在可以处理其他响应格式，即图像、视频文件、纯文本或任何其他内容类型。它添加了更多方法（即 POST 和 HEAD），更改了请求/响应格式，将 HTTP 标头添加到请求和响应中，添加了状态代码以标识响应，引入了字符集支持，包括多部分类型、授权、缓存、内容编码等。

下面是示例 HTTP/1.0 请求和响应的样子：

```
GET / HTTP/1.0
Host: cs.fyi
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

如您所见，除了请求外，客户还发送了个人信息、所需的响应类型等。在 HTTP/0.9 中，客户端永远无法发送此类信息，因为没有标头。

对上述请求的示例响应可能如下所示

```
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

(response body)
(connection closed)
```

在响应的开头有 HTTP/1.0（HTTP 后跟版本号），然后是状态代码 200，后跟原因短语（或状态代码的描述，如果你愿意的话）。

在这个较新的版本中，请求和响应标头仍保持为 ASCII 编码，但响应正文可以是任何类型，即图像、视频、HTML、纯文本或任何其他内容类型。因此，现在服务器可以向客户端发送任何内容类型;在引入后不久，HTTP中的术语“超文本”就变得用词不当。HMTP 或超媒体传输协议可能更有意义，但我想，我们终生被这个名字所困扰。

HTTP/1.0 的主要缺点之一是每个连接不能有多个请求。也就是说，每当客户端需要从服务器获取某些内容时，它都必须打开一个新的 TCP 连接，并且在满足该单个请求后，连接将被关闭。对于任何下一个要求，它都必须在新的连接上。为什么不好？好吧，假设您访问一个包含 10 张图像、5 个样式表和 5 个 javascript 文件的网页，总共有 20 个项目，在向该网页发出请求时需要获取这些项目。由于服务器在满足请求后立即关闭连接，因此将有一系列 20 个单独的连接，其中每个项目都将在其单独的连接上逐个提供服务。这种大量的连接会导致严重的性能下降，因为需要新的 TCP 连接会造成严重的性能损失，因为三次握手后启动速度很慢。

### 三向握手

简单形式的三向握手是所有TCP连接都以三向握手开始，其中客户端和服务器在开始共享应用程序数据之前共享一系列数据包。

- SYN - 客户端拾取一个随机数，比如说 x，并将其发送到服务器。
- SYN ACK - 服务器通过向客户端发送回 ACK 数据包来确认请求，该数据包由随机数组成，假设服务器拾取了 y 和数字 x+1，其中 x 是客户端发送的数字
- ACK - 客户端递增从服务器接收的数字 y，并发送回编号为 y+1 的 ACK 数据包

三次握手完成后，客户端和服务器之间的数据共享就可以开始了。需要注意的是，客户端可能会在发送最后一个 ACK 数据包后立即开始发送应用程序数据，但服务器仍必须等待接收到 ACK 数据包才能满足请求。

![3 次握手](https://i.imgur.com/ohZthqB.png)

但是，HTTP/1.0 的一些实现试图通过引入一个名为 Connection： keep-alive 的新标头来克服这个问题，该标头旨在告诉服务器“嘿服务器，不要关闭此连接，我需要它”。但是，它仍然没有得到广泛的支持，问题仍然存在。

除了无连接之外，HTTP也是一种无状态协议，即服务器不维护有关客户端的信息，因此每个请求都必须具有服务器自行完成请求所需的信息，而无需与任何旧请求关联。因此，这火上浇油，即除了客户端必须打开的大量连接外，它还必须在线路上发送一些冗余数据，从而导致带宽使用量增加。

## HTTP/1.1 - 1997年

在 HTTP/1.0 推出仅 3 年后，下一个版本即 HTTP/1.1 于 1999 年发布;这比它的前身做了很多改进。对 HTTP/1.0 的主要改进包括

- 添加了新的 HTTP 方法，引入了 PUT、PATCH、OPTIONS、DELETE
    
- 主机名标识 在 HTTP/1.0 中，主机标头不是必需的，但 HTTP/1.1 是必需的。
    
- 持久连接 如上所述，在 HTTP/1.0 中，每个连接只有一个请求，并且一旦请求得到满足，连接就会关闭，这会导致严重的性能影响和延迟问题。HTTP/1.1 引入了持久连接，即连接默认不关闭并保持打开状态，从而允许多个顺序请求。若要关闭连接，标头 Connection： close 必须在请求中可用。客户端通常在最后一个请求中发送此标头，以安全地关闭连接。
    
- 流水线 它还引入了对流水线的支持，其中客户端可以向服务器发送多个请求，而无需等待来自同一连接上的服务器的响应，并且服务器必须按照接收请求的相同顺序发送响应。但是，您可能会问，客户端如何知道这是第一个响应下载完成和下一个响应内容开始的时间点！好吧，为了解决这个问题，必须存在 Content-Length 标头，客户端可以使用它来识别响应的结束位置，并且它可以开始等待下一个响应。
    

> 应该注意的是，为了从持久连接或流水线中受益，Content-Length 标头必须在响应上可用，因为这将让客户端知道传输何时完成，并且它可以发送下一个请求（以发送请求的正常顺序方式）或开始等待下一个响应（启用流水线时）。
> 
> 但这种方法仍然存在问题。也就是说，如果数据是动态的，服务器无法事先找到内容长度怎么办？好吧，在这种情况下，你真的无法从持久连接中受益，不是吗？！为了解决这个问题，HTTP/1.1引入了分块编码。在这种情况下，服务器可能会省略 content-Length 以支持分块编码（稍后会详细介绍）。但是，如果它们都不可用，则必须在请求结束时关闭连接。

- 分块传输 在动态内容的情况下，当服务器在传输开始时无法真正找到 Content-Length 时，它可能会开始分段（逐块）发送内容，并在发送时为每个块添加 Content-Length。当所有块都发送完毕（即整个传输已完成）时，它会发送一个空块，即 Content-Length 设置为零的块，以标识传输已完成的客户端。为了通知客户端分块传输，服务器包含标头 Transfer-Encoding： chunked
    
- 与仅具有基本身份验证的 HTTP/1.0 不同，HTTP/1.1 包括摘要式和代理身份验证
    
- 缓存
    
- 字节范围
    
- 字符集
    
- 语言协商
    
- 客户端 Cookie
    
- 增强的压缩支持
    
- 新状态代码
    
- ..和更多
    

我不打算在这篇文章中详述所有 HTTP/1.1 功能，因为它本身就是一个主题，你已经可以找到很多关于它的信息。我建议您阅读的一份这样的文档是 HTTP/1.0 和 HTTP/1.1 之间的[主要区别](http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf)，这里是指向优秀者[的原始 RFC](https://tools.ietf.org/html/rfc2616) 的链接。

HTTP/1.1 于 1999 年推出，多年来一直是标准。虽然，它比它的前身改进了很多;随着网络每天都在变化，它开始显示出它的年龄。如今，加载网页比以往任何时候都更加耗费资源。如今，一个简单的网页必须打开 30 多个连接。那么 HTTP/1.1 有持久连接，那为什么会有这么多连接呢？你说！原因是，在 HTTP/1.1 中，它在任何时候都只能有一个未完成的连接。HTTP/1.1 试图通过引入流水线来解决这个问题，但它并没有完全解决这个问题，因为行头阻塞，其中缓慢或繁重的请求可能会阻止后面的请求，一旦请求卡在管道中，它将不得不等待下一个请求得到满足。为了克服 HTTP/1.1 的这些缺点，开发人员开始实施变通方法，例如使用精灵表、CSS 中的编码图像、单个 humungous CSS/Javascript 文件、域分片等。

## SPDY - 2009年

谷歌继续前进，开始尝试替代协议，以使网络更快，提高网络安全性，同时减少网页的延迟。2009 年，他们宣布了 SPDY。

> SPDY 是 Google 的商标，不是首字母缩写词。

可以看出，如果我们不断增加带宽，网络性能在开始时会提高，但当性能提升不大时，就会出现一个点。但是，如果您对延迟做同样的事情，即如果我们不断降低延迟，则性能会不断提高。这是SPDY背后的性能提升的核心思想，减少延迟以提高网络性能。

> 对于那些不知道区别的人来说，延迟是延迟，即数据在源和目标之间传输所需的时间（以毫秒为单位），带宽是每秒传输的数据量（每秒比特）。

SPDY的功能包括多路复用、压缩、优先级、安全性等。我不打算深入探讨 SPDY 的细节，因为当我们在下一节中深入了解 HTTP/2 的细节时，您会明白，正如我所说，HTTP/2 主要受到 SPDY 的启发。

SPDY 并没有真正尝试取代 HTTP;它是存在于应用程序层的 HTTP 转换层，并在将请求发送到网络之前对其进行了修改。它开始成为事实上的标准，大多数浏览器开始实现它。

2015 年，在 Google，他们不想有两个相互竞争的标准，因此他们决定将其合并到 HTTP 中，同时催生 HTTP/2 并弃用 SPDY。

## HTTP/2 - 2015年

到现在为止，您必须确信为什么我们需要对 HTTP 协议进行另一个修订。HTTP/2 专为内容的低延迟传输而设计。与旧版本的 HTTP/1.1 的主要功能或区别包括

- 二进制而不是文本
- 多路复用 - 通过单个连接发出多个异步 HTTP 请求
- 使用 HPACK 的标头压缩
- 服务器推送 - 单个请求的多个响应
- 请求优先级
- 安全

![](https://i.imgur.com/X1BT5eX.png)

### 1. 二进制协议

HTTP/2 倾向于通过使其成为二进制协议来解决 HTTP/1.x 中存在的延迟增加问题。作为一种二进制协议，它更容易解析，但与 HTTP/1.x 不同的是，它不再被人眼读取。HTTP/2 的主要构建块是帧和流

#### 帧和流

HTTP 消息现在由一个或多个帧组成。元数据有一个 HEADERS 帧，有效负载有一个 DATA 帧，并且存在几种其他类型的帧（HEADERS、DATA、RST_STREAM、SETTINGS、PRIORITY 等），您可以通过 [HTTP/2 规范](https://http2.github.io/http2-spec/#FrameTypes)进行检查。

每个 HTTP/2 请求和响应都有一个唯一的流 ID，并将其划分为帧。帧只不过是二进制数据。帧的集合称为 Stream。每个帧都有一个流 ID，用于标识它所属的流，并且每个帧都有一个公共标头。此外，除了流 ID 是唯一的之外，值得一提的是，客户端发起的任何请求都使用奇数，而来自服务器的响应具有偶数流 ID。

除了 HEADERS 和 DATA 之外，我认为这里值得一提的另一种帧类型是 RST_STREAM，这是一种特殊的帧类型，用于中止某些流，即客户端可能会发送此帧以让服务器知道我不再需要此流。在 HTTP/1.1 中，使服务器停止向客户端发送响应的唯一方法是关闭连接，这会导致延迟增加，因为必须为任何连续请求打开新连接。在 HTTP/2 中，客户端可以使用 RST_STREAM 并停止接收特定流，而连接仍将处于打开状态，而其他流仍将处于运行状态。

### 2. 多路复用

由于 HTTP/2 现在是一种二进制协议，并且正如我上面所说，它使用帧和流进行请求和响应，因此一旦打开 TCP 连接，所有流都会通过同一连接异步发送，而无需打开任何其他连接。反过来，服务器以相同的异步方式进行响应，即响应没有顺序，客户端使用分配的流 ID 来识别特定数据包所属的流。这也解决了 HTTP/1.x 中存在的线头阻塞问题，即客户端不必等待需要时间的请求，其他请求仍将得到处理。

### 3. 标头压缩

它是单独RFC的一部分，专门用于优化发送的标头。它的本质是，当我们不断从同一客户端访问服务器时，我们会一遍又一遍地在标头中发送大量冗余数据，有时可能会有 cookie 增加标头大小，从而导致带宽使用和延迟增加。为了克服这个问题，HTTP/2 引入了标头压缩。

与请求和响应不同，标头不是以 gzip 或 compress etc 格式压缩的，但标头压缩有不同的机制，即使用 Huffman 代码对文本值进行编码，并且客户端和服务器维护标头表，客户端和服务器在后续请求中省略任何重复的标头（例如用户代理等），并使用两者维护的标头表引用它们。

当我们谈论标头时，让我在这里补充一点，标头仍然与 HTTP/1.1 中的标头相同，除了添加了一些伪标头，即 、 和`:method``:scheme``:host``:path`

### 4. 服务器推送

服务器推送是 HTTP/2 的另一个重要功能，服务器知道客户端将请求某个资源，可以将其推送到客户端，甚至无需客户端请求。例如，假设浏览器加载一个网页，它解析整个页面以找出它必须从服务器加载的远程内容，然后向服务器发送相应的请求以获取该内容。

服务器推送允许服务器通过推送它知道客户端将要需要的数据来减少往返。它是如何完成的，服务器发送一个名为PUSH_PROMISE的特殊帧，通知客户端，“嘿，我即将将这个资源发送给你！不要问我。PUSH_PROMISE帧与导致推送发生的流相关联，它包含承诺的流 ID，即服务器将发送要推送的资源的流。

### 5. 请求优先级

客户端可以通过在打开流的 HEADERS 帧中包含优先级信息来为流分配优先级。在任何其他时间，客户端都可以发送 PRIORITY 帧来更改流的优先级。

在没有任何优先级信息的情况下，服务器异步处理请求，即没有任何顺序。如果为流分配了优先级，则根据此优先级信息，服务器将决定需要提供多少资源来处理哪个请求。

### 6. 安全

关于是否应该强制要求 HTTP/2 强制使用安全性（通过 TLS）进行了广泛的讨论。最后，决定不强制执行。但是，大多数供应商表示，他们只会在通过 TLS 使用 HTTP/2 时才支持它。因此，尽管 HTTP/2 不需要按规范加密，但无论如何，它已成为默认的强制性要求。除此之外，HTTP/2 在 TLS 上实现时确实会提出一些要求，即必须使用 TLS 版本 1.2 或更高版本，必须有一定级别的最小密钥大小，需要临时密钥等。